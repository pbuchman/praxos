name: Coverage Analysis & Issue Creation

on:
  workflow_dispatch:
  schedule:
    # Run weekly on Monday at 6:00 AM UTC
    - cron: '0 6 * * 1'

permissions:
  contents: read
  issues: write

jobs:
  analyze-coverage:
    name: Analyze Coverage & Create Issues
    runs-on: ubuntu-latest
    environment: copilot

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install

      - name: Build
        run: pnpm run build

      - name: Run tests with coverage
        run: pnpm run test:coverage

      - name: Analyze coverage and create issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            // Read coverage summary
            const coveragePath = 'coverage/coverage-summary.json';
            if (!fs.existsSync(coveragePath)) {
              console.log('Coverage summary not found');
              return;
            }

            const coverage = JSON.parse(fs.readFileSync(coveragePath, 'utf8'));
            const total = coverage.total;

            console.log('=== Coverage Summary ===');
            console.log(`Lines: ${total.lines.pct}%`);
            console.log(`Branches: ${total.branches.pct}%`);
            console.log(`Functions: ${total.functions.pct}%`);
            console.log(`Statements: ${total.statements.pct}%`);

            // Get existing coverage issues
            const { data: existingIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'coverage,testing',
              state: 'open',
              per_page: 100
            });

            console.log(`Found ${existingIssues.length} existing coverage issues`);

            // Analyze files with incomplete coverage
            const filesWithGaps = [];
            const THRESHOLD = 90;

            for (const [filePath, data] of Object.entries(coverage)) {
              if (filePath === 'total') continue;

              // Skip excluded patterns
              if (filePath.includes('__tests__') ||
                  filePath.includes('.test.') ||
                  filePath.includes('/testing/') ||
                  filePath.includes('index.ts') ||
                  filePath.includes('server.ts') ||
                  filePath.includes('services.ts') ||
                  filePath.includes('adapters.ts') ||
                  filePath.includes('/models/') ||
                  filePath.includes('/ports/') ||
                  filePath.includes('/events/') ||
                  filePath.includes('apps/web/') ||
                  filePath.includes('apps/api-docs-hub/')) {
                continue;
              }

              const branchPct = data.branches.pct;
              const linePct = data.lines.pct;

              if (branchPct < THRESHOLD || linePct < THRESHOLD) {
                // Extract uncovered lines
                const uncoveredLines = [];
                if (data.linesCovered && data.linesTotal) {
                  // Extract from detailed coverage if available
                }

                filesWithGaps.push({
                  path: filePath.replace(process.cwd() + '/', ''),
                  lines: linePct,
                  branches: branchPct,
                  functions: data.functions.pct,
                  statements: data.statements.pct
                });
              }
            }

            // Sort by branch coverage (lowest first)
            filesWithGaps.sort((a, b) => a.branches - b.branches);

            console.log(`\nFound ${filesWithGaps.length} files with coverage gaps`);

            // Generate report
            const date = new Date().toISOString().split('T')[0];
            let report = `# Code Coverage Analysis Report\n\n`;
            report += `**Generated:** ${date}\n`;
            report += `**Current Coverage:** Lines ${total.lines.pct}%, Branches ${total.branches.pct}%, Functions ${total.functions.pct}%, Statements ${total.statements.pct}%\n`;
            report += `**Thresholds:** 90% for all metrics\n\n`;

            if (total.branches.pct >= 90 && total.lines.pct >= 90) {
              report += `‚úÖ **All coverage thresholds met!**\n\n`;
            } else {
              report += `‚ö†Ô∏è **Coverage below thresholds**\n\n`;
            }

            report += `## Files with Coverage Gaps (< ${THRESHOLD}%)\n\n`;
            report += `| File | Lines | Branches | Priority |\n`;
            report += `|------|-------|----------|----------|\n`;

            for (const file of filesWithGaps.slice(0, 20)) {
              const priority = file.branches < 70 ? 'üî¥ High' : file.branches < 85 ? 'üü† Medium' : 'üü¢ Low';
              const shortPath = file.path.split('/').slice(-2).join('/');
              report += `| ${shortPath} | ${file.lines.toFixed(1)}% | ${file.branches.toFixed(1)}% | ${priority} |\n`;
            }

            report += `\n## Existing Open Issues\n\n`;
            if (existingIssues.length === 0) {
              report += `No open coverage issues found.\n`;
            } else {
              for (const issue of existingIssues) {
                report += `- #${issue.number}: ${issue.title}\n`;
              }
            }

            console.log('\n=== Generated Report ===');
            console.log(report);

            // Create or update tracking issue
            const trackingTitle = `[Coverage] Weekly Analysis Report - ${date}`;

            // Check if tracking issue already exists for this week
            const { data: weeklyIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'coverage,automated',
              state: 'all',
              per_page: 10
            });

            const existingWeeklyIssue = weeklyIssues.find(i => i.title.includes(date));

            if (existingWeeklyIssue) {
              // Update existing issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingWeeklyIssue.number,
                body: `## Updated Analysis\n\n${report}`
              });
              console.log(`Updated existing issue #${existingWeeklyIssue.number}`);
            } else {
              // Create new tracking issue
              const { data: newIssue } = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: trackingTitle,
                body: report,
                labels: ['coverage', 'automated', 'tracking']
              });
              console.log(`Created tracking issue #${newIssue.number}`);
            }

            // Create individual issues for high-priority gaps (if not already exists)
            const highPriorityFiles = filesWithGaps.filter(f => f.branches < 95).slice(0, 5);

            for (const file of highPriorityFiles) {
              const shortPath = file.path.split('/').slice(-2).join('/');
              const issueTitle = `[Coverage] ${shortPath} - Improve branch coverage from ${file.branches.toFixed(1)}% to 90%+`;

              // Check if issue already exists
              const existingIssue = existingIssues.find(i =>
                i.title.includes(shortPath) || i.title.includes(file.path)
              );

              if (existingIssue) {
                console.log(`Issue already exists for ${shortPath}: #${existingIssue.number}`);
                continue;
              }

              // Determine service name from path
              let serviceName = 'Unknown Service';
              if (file.path.includes('user-service')) serviceName = 'User Service';
              else if (file.path.includes('whatsapp-service')) serviceName = 'WhatsApp Service';
              else if (file.path.includes('promptvault-service')) serviceName = 'PromptVault Service';
              else if (file.path.includes('notion-service')) serviceName = 'Notion Service';
              else if (file.path.includes('mobile-notifications-service')) serviceName = 'Mobile Notifications Service';
              else if (file.path.includes('packages/common')) serviceName = 'Common Package';

              const issueBody = `## Objective

            Improve branch coverage in \`${file.path}\` from ${file.branches.toFixed(1)}% to at least 90%.

            ## ‚ö†Ô∏è MANDATORY: Repository Standards

            Before writing ANY code, you MUST:

            1. **Read \`.github/copilot-instructions.md\`** ‚Äî all coding standards
            2. **Read \`.github/instructions/apps.instructions.md\`** ‚Äî app patterns
            3. **Run Prettier before CI**: \`pnpm prettier --write .\`
            4. **All verification must pass**: \`pnpm run ci\`

            ## Target File

            \`${file.path}\`

            **Current Coverage:**
            - Lines: ${file.lines.toFixed(1)}%
            - Branches: ${file.branches.toFixed(1)}%
            - Functions: ${file.functions.toFixed(1)}%
            - Statements: ${file.statements.toFixed(1)}%

            ## Analysis Required

            1. Run \`pnpm run test:coverage\` and identify uncovered lines
            2. Analyze which branches are not covered
            3. Create targeted tests for uncovered paths

            ## Acceptance Criteria

            - [ ] Branch coverage ‚â• 90% for this file
            - [ ] All new tests pass
            - [ ] \`pnpm run ci\` passes

            ## Coverage Reporting (REQUIRED)

            **Before starting**, run:
            \`\`\`bash
            pnpm run test:coverage 2>&1 | grep -A2 "${shortPath}"
            \`\`\`

            **After completing**, include BOTH outputs in PR description.

            ---
            *Generated by Coverage Analysis workflow on ${date}*`;

              const { data: createdIssue } = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: issueTitle,
                body: issueBody,
                labels: ['coverage', 'testing', 'copilot', 'automated']
              });

              console.log(`Created issue #${createdIssue.number} for ${shortPath}`);
            }

            console.log('\n=== Workflow completed ===');
