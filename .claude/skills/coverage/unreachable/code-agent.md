# Coverage Exemptions: code-agent

> Auto-generated by `/coverage`. Manual edits preserved if format maintained.

## Summary

| Metric | Count |
|--------|-------|
| Total exempted branches | 2 |
| Last verified | 2026-01-26 |

---

## `src/infra/repositories/firestoreLogChunkRepository.ts`

### Line ~54: Firestore batch.commit() error catch block

```typescript
try {
  await batch.commit();
  this.logger.debug({ taskId, count: chunks.length }, 'Stored log chunks');
  return ok(undefined);
} catch (error) {
  this.logger.error({ taskId, error: getErrorMessage(error) }, 'Failed to store log chunks');
  return err({ code: 'FIRESTORE_ERROR', message: getErrorMessage(error) });
  //     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
}
```

- **Blocker:** Test Infrastructure Constraints
- **Proof:** The `FirestoreLogChunkRepository.storeBatch()` method uses Firestore subcollection chaining: `collection('code_tasks').doc(taskId).collection('logs').doc()`. The test file (`firestoreLogChunkRepository.test.ts`) explicitly notes: "Fake firestore doesn't support subcollection chaining (collection().doc().collection())". The fake from `@intexuraos/infra-firestore` (`createFakeFirestore()`) only supports top-level collections. To test the catch block, we would need the fake to:
  1. Support subcollection chaining
  2. Then have a mechanism to make `batch.commit()` throw
  Neither capability exists in the current fake. The actual Firestore operations ARE tested via integration tests in `webhooks.test.ts`.
- **Pattern:** Subcollection operations untestable with current fake

---

## `src/infra/webhookValidation.ts`

### Line ~89: Array timestamp empty first element fallback

```typescript
const timestampStr = Array.isArray(timestamp) ? timestamp[0] ?? '' : timestamp;
//                                              ^^^^^^^^^^^^^^^^^
```

- **Blocker:** TypeScript Type System Guarantees
- **Proof:** The `request.headers['x-request-timestamp']` type is `string | string[] | undefined`. When `Array.isArray(timestamp)` is true, TypeScript narrows to `string[]`. The `timestamp[0]` access with `noUncheckedIndexedAccess` requires the `?? ''` fallback for the empty array case. However, HTTP standards and Fastify behavior guarantee that when a header appears multiple times, the array will contain at least one element (each header value). An empty array (`[]`) is never produced by Fastify's header parsing - if no header exists, it's `undefined`, not `[]`. The `?? ''` fallback exists to satisfy TypeScript's strict type checking but represents a state that HTTP/Fastify cannot produce.
- **Pattern:** noUncheckedIndexedAccess defensive code

---

## Verification Date: 2026-01-26

## Auditor: Claude Code
