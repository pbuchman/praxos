# Unreachable Entry Template

## File Structure

Each `unreachable/<name>.md` follows this structure:

```markdown
# Coverage Exemptions: <name>

> Auto-generated by `/coverage`. Manual edits preserved if format maintained.

## Summary

| Metric | Count |
|--------|-------|
| Total exempted branches | <N> |
| Last verified | <YYYY-MM-DD> |

---

## `<relative-path-to-file>`

### Line ~<N>: <brief-description>

\`\`\`typescript
<code-snippet-with-marker>
\`\`\`

- **Reason:** <why this is unreachable>
- **Pattern:** <optional-link-to-common-patterns.md>

---

## `<another-file>`

...
```

## Entry Format

### Section Header

Use relative path from app/package root:
- `## \`src/infra/http/client.ts\``
- NOT `## \`apps/actions-agent/src/infra/http/client.ts\``

### Line Reference

Use approximate line with tilde:
- `### Line ~45:` — indicates "around line 45"
- Line numbers change; the CODE SNIPPET is the source of truth

### Brief Description

Short identifier for the branch:
- `?? 'info'` fallback
- `if (user === null)` guard
- `Array.isArray(value)` check

### Code Snippet

Include enough context to find the code:

```typescript
const logger = pino({ level: process.env['LOG_LEVEL'] ?? 'info' });
//                                                     ^^^^^^^^
```

**Requirements:**
- Include the actual uncovered code
- Use `^^^^^^^^` or similar to mark the specific branch
- 3-10 lines typically sufficient
- Must be searchable in source file

### Blocker Category (REQUIRED)

Must be one of the 7 valid categories from [verification-methodology.md](../reference/verification-methodology.md):

1. TypeScript Type System Guarantees
2. Regex Match Guarantees
3. Module-Level Initialization
4. Async Callback Timing
5. Test Infrastructure Constraints
6. Upstream Guards
7. ES Module Mocking Limitations

### Proof (REQUIRED)

Explain the SPECIFIC MECHANISM that prevents test access:
- NOT just "this is unreachable"
- NOT just "TypeScript requires this"
- MUST explain WHY structurally impossible

Example proofs:
- "Line 42 checks `length === 3`. TypeScript narrows indices 0-2 to defined. The undefined check on line 45 is dead code."
- "`FakeAuthPlugin` has no `setUnauthenticated()` method. All test requests are authenticated by design."
- "Regex `/^##\s+(.+)$/` requires `.+` in group 1. If match succeeds, group 1 cannot be undefined."

### Pattern Reference (Optional)

Link to common pattern if applicable:
- `**Pattern:** noUncheckedIndexedAccess (see reference/common-patterns.md)`
- `**Pattern:** Auth guard (tests authenticated)`

## Example Entry

```markdown
## `src/routes/actionRoutes.ts`

### Line ~120: `if (user === null)` authentication guard

\`\`\`typescript
const user = await requireAuth(request, reply);
if (user === null) {
  return;  // ← Unreachable in tests
}
\`\`\`

- **Blocker:** Test Infrastructure Constraints
- **Proof:** `FakeAuthPlugin` (in `__tests__/fakes.ts`) has no `setUnauthenticated()` method. All injected requests include valid auth headers. The null branch requires an unauthenticated request, which the test fake cannot produce. Auth failure paths are tested at the middleware level in `auth.test.ts`.
- **Pattern:** Auth guard (tests authenticated)
```

## Verification

An entry is VALID if:
1. The code snippet can be found in the current source file
2. The branch is still uncovered in latest coverage run
3. The reason accurately explains why it's unreachable

An entry is STALE if:
1. Code snippet not found (refactored/deleted)
2. Branch is now covered by tests
3. File no longer exists
